\documentclass{llncs}
\usepackage{latexsym}
\usepackage{times}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{adjustbox}
\usepackage{marvosym}
%% Colored hyperlink 
\newcommand{\cref}[2]{\href{#1}{\color{blue}#2}}
%% Colored hyperlink showing link in TT font
% \newcommand{\chref}[1]{\href{#1}{\small\tt \color{blue}#1}}
\newcommand{\hcref}[1]{\cref{#1}{\small\tt #1}}

\bibliographystyle{splncs04}
%\bibliographystyle{abbrv}

\newcommand{\one}{\mbox{\bf 1}}
\newcommand{\zero}{\mbox{\bf 0}}
\newcommand{\leafone}{L_1}
\newcommand{\leafzero}{L_0}
\newcommand{\booland}{\land}
\newcommand{\boolor}{\lor}
\newcommand{\boolxor}{\oplus}
\newcommand{\boolnot}{\neg}
%\newcommand{\tautology}{\top}
%\newcommand{\nil}{\bottom}
\newcommand{\tautology}{1}
\newcommand{\nil}{0}
\newcommand{\obar}[1]{\overline{#1}}
\newcommand{\ite}{\mbox{\it ITE}}

\newcommand{\opname}[1]{\mbox{\sc #1}}
\newcommand{\andop}{\opname{And}}
\newcommand{\implyop}{\opname{Imply}}

\newcommand{\turnstile}{\vdash}

\newcommand{\fname}[1]{\mbox{\small\sf #1}}

\newcommand{\lo}{\fname{Lo}}
\newcommand{\hi}{\fname{Hi}}
\newcommand{\var}{\fname{Var}}
\newcommand{\val}{\fname{Val}}

\newcommand{\interp}{\alpha}
\newcommand{\interpset}[1]{{\cal M}(#1)}
\newcommand{\ring}{{\cal Z}}
\newcommand{\cost}{\sigma}
\newcommand{\density}{\rho}
\newcommand{\hashset}{{\cal H}}
\newcommand{\fhash}{h}
\newcommand{\mcount}{\mu}

\newcommand{\ifarg}{\textbf{I}}
\newcommand{\thenarg}{\textbf{T}}
\newcommand{\elsearg}{\textbf{E}}
\newcommand{\depend}{{\it D}}

\newcommand{\subs}[2]{[#2/#1]}
\newcommand{\substrue}[1]{\subs{#1}{\tautology}}
\newcommand{\subsfalse}[1]{\subs{#1}{\false}}
\newcommand{\subsflip}[1]{\subs{#1}{\obar{#1}}}

\newcommand{\subspace}{{\cal S}}

\title{Notes on Validated Model Counting \\ Version of \today}

\author{Randal E. Bryant}

\authorrunning{R. E. Bryant}

\titlerunning{Validated Model Counting}


\institute{
Computer Science Department \\
Carnegie Mellon University, Pittsburgh, PA, United States
}

\begin{document}

\maketitle

\section{Notation}

Let $X = \{x_1, x_2, \ldots, x_n\}$ be a set of Boolean variables.  An
{\em assignment} is a function $\interp$ assigning Boolean values to
the variables: $\interp:X \rightarrow \{\nil, \tautology\}$.  We can
also view an assignment as a set of {\em literals} $\{l_1, l_2,
\ldots, l_n\}$, where each literal $l_i$ is either $x_i$ or
$\obar{x}_i$, corresponding to the assignments $\interp(x_i)$ = 1 or 0,
respectively.

\subsection{Boolean Functions}

A {\em Boolean function} $f:2^X \rightarrow \{0,1\}$ can be
characterized by the set of assignments for which the function
evaluates to 1: $\interpset{f} = \{ \interp | f(\interp) = 1\}$.  Let
$\one$ denote the Boolean function that assigns value 1 to every
assignment, and $\zero$ denote the assignment that assigns value 0 to
every assignment.  These are characterized by the universal and empty
assignment sets, respectively.


From
this we can define the {\em negation} of function $f$ as the function
$\boolnot f$ such that
$\interpset{\boolnot f} = \{ \interp | f(\interp) = 0\}$.
We can also define the conjunction and disjunction operations over functions $f_1$ and $f_2$ as characterized by the sets
$\interpset{f_1 \booland f_2} = \interpset{f_1} \cap \interpset{f_2}$ and
$\interpset{f_1 \boolor f_2} = \interpset{f_1} \cup \interpset{f_2}$.

For assignment $\interp$ and a Boolean formula $E$ over $X$, we
use the notation $\interp\subs{x_i}{E}$ to denote the assignment
$\interp'$, such that $\interp'(x_j) = \interp(x_j)$ for all $j \not = i$
and $\interp'(x_i) = \interp(E)$, where $\interp(E)$ is the value obtained by evaluating formula $E$ with each variable assigned the value given by $\interp$.
In particular, the notation
$\interp\subsflip{x_i}$ indicates the assignment in which the value
assigned to $x_i$ is complemented, while others remain unchanged.

A Boolean function $f$ is said to be {\em independent} of variable
$x_i$ if every $\interp \in \interpset{f}$ has $\interp\subsflip{x_i}
\in \interpset{f}$.  The {\em dependency set} of $f$, denoted
$\depend(f)$ consists of all variables $x_i$ for which $f$ is {\em
  not} independent.

\subsection{Separable Cost Functions}

Let $\ring$ denote the elements of a commutative ring.  A {\em
  separable cost function} $\cost:X \rightarrow \ring$ assigns a value
from the ring to each variable.  We extend this function by defining
the cost of literal as $\cost(\obar{x}_i) = 1 - \cost(x_i)$, the cost
of an assignment as $\cost(\interp) = \prod_{l_i \in \interp}
\cost(l_i)$, and the cost of a function $f$ as $\cost(f) =
\sum_{\interp \in \interpset{f}} \cost(\interp)$.

{\bf Example 1}: Let $\ring$ be the set of rational numbers and
$\cost(x_i) = 1/2$ for all variables $x_i$.  Then cost of every
assignment will be $1/2^{n}$, and the cost of a function will be its
{\em density}, denoted $\density(f)$.  That is $\density(f) \in [0,
  1]$ will be the fraction of assignments for which the function
evaluates to 1.  Given an ability to compute the density of
function $f$, we can scale this by $2^n$ to compute $|\interpset{f}|$, the core task of model counting.
Using density as our metric has the advantage that it
does not vary when the function is embedded in a larger domain $X'
\supseteq X$.

{\bf Example 2}: Let $\ring$ be a field with $|\ring| > 2n$,
and let $\hashset$ be the set functions
mapping elements of $X$ to elements of $\ring$.  For
two distinct functions $f_1$ and $f_2$ and a randomly chosen $\fhash
\in \hashset$, the probability that $h(f_1) = h(f_2)$ will be at most
$2^n/|\ring|< 1/2$.  Therefore, these functions can be used as part of a
randomized algorithm for equivalence testing~\cite{blum:ipl:1980}.

\subsection{Computing Cost Functions}

Three key properties of separable cost functions makes it
possible, in some cases, to compute the cost of a Boolean formula without enumerating all of its satisfying solutions.

\begin{lemma}[Complementation]
  For separable cost function $\cost$ and Boolean function $f$:
  $\cost(\neg f) = 1 - \cost(f)$.
\end{lemma}

\begin{lemma}[Conjunction over Independent Domains]
  For separable cost function $\cost$ and Boolean functions $f_1$ and $f_2$ such that $\depend(f_1) \cap \depend(f_2) = \emptyset$:
    $\cost(f_1 \land f_2) = \cost(f_1) \cdot \cost(f_2)$.
\end{lemma}

\begin{lemma}[Disjunction over Disjoint Domains]
  For separable cost function $\cost$ and Boolean functions $f_1$ and $f_2$ such that $\interpset{f_1} \cap \interpset{f_2} = \emptyset$:
    $\cost(f_1 \lor f_2) = \cost(f_1) + \cost(f_2)$.
\end{lemma}

\bibliography{references}

\end{document}


Consider Boolean formulas over a set of variables $X$.  An
assignment $\interp$ is a function mapping each variable to 
truth value $\tautology$ (true) or $\nil$ (false).  We can extend
$\interp$ to Boolean formulas in the normal way, such that
$\interp(F)$ will be $\tautology$ (respectively, $\nil$) if the
evaluation of formula $F$ yields $\tautology$ (resp., $\nil$) when its
variables are assigned values according to $\interp$.

For Boolean formula $F$, we define its set of {\em models} $\interpset{F}$ as
\begin{eqnarray}
\interpset{F} & = & \{ \interp | \interp(F) = \tautology \}
\end{eqnarray}
The task of model counting is, given formula $F$, to determine the size of its set of models
$\mcount(F) = |\interpset{F}|$.  Ideally, this should be done without actually enumerating the set.

For assignment $\interp$ and a Boolean formula $E$ over $X$, we
use the notation $\interp\subs{x}{E}$ to denote the assignment
$\interp'$, such that $\interp'(y) = \interp(y)$ for all $y \not = x$
and $\interp'(x) = \interp(E)$.  In particular, the notation
$\interp\subsflip{x}$ indicates the assignment in which the value
assigned to $x$ is complemented, while others remain unchanged.

A Boolean formula $F$ is said to be {\em independent} of variable $x$
if every $\interp \in \interpset{F}$ has $\interp\subsflip{x} \in
\interpset{F}$.

The following lemmas describe the primary abstractions used to perform
model counting without enumerating all solutions.

\begin{lemma}
  \label{lemma:negation}
  For any formula $F$:
  \begin{eqnarray*}
    \mcount(\neg F) & =  & 2^n - \mcount(F)
  \end{eqnarray*}
\end{lemma}

\begin{lemma}
  \label{lemma:product}
  For a partitioning of the variables $X$ into disjoint sets $X_1$ and $X_2$, and for formulas $F_1$ defined over $X_1$ and $F_2$ defined over $X_2$:
  \begin{eqnarray*}
    \mcount(F_1 \land F_2) &=& \mcount(F_1) \cdot \mcount(F_2)
  \end{eqnarray*}
\end{lemma}

\begin{lemma}
  \label{lemma:sum}
  For formulas $F_1$ and $F_2$ such that $\interpset{F_1} \cap \interpset{F_2} = \emptyset$:
  \begin{eqnarray*}
    \mcount(F_1 \lor F_2) &=& \mcount(F_1) + \mcount(F_2)
  \end{eqnarray*}
\end{lemma}

\section{ITE Operation}

We consider a single Boolean operation, known as
``If-Then-Else,'' or simply ``ITE.''  For Boolean values $a, b, c$,
the operation is defined as $\ite(a,b,c) = (a \land b) \lor (\neg a
\land c)$.  This single operation can be used to express several common Boolean operations:
\begin{eqnarray*}
\neg a & = & \ite(a, \nil, \tautology) \\
a \land b & = & \ite(a, b, \nil) \\
a \lor b & = & \ite(a, \tautology, b) \\
a \rightarrow b & = & \ite(a, b, \tautology) \\
\end{eqnarray*}  

For variable $x$ and Boolean formulas $F$ and $G$, the set of models
for $\ite(x, F, G)$ is given by the formula:
\begin{eqnarray}
  \interpset{\ite(x, F, G)} & = & \{ \interp \in \interpset{F} | \interp(x) = \tautology \}
  \cup \{ \interp \in \interpset{G} | \interp(x) = \nil \} \label{eqn:ite:interp}
\end{eqnarray}

\section{ITE Graphs}

An {\em ITE graph} describes a combinational logic circuit constructed from two-input multiplexors.
It is defined as a directed acyclic graph
with three node types:
\begin{description}
\item[Constant:] Corresponds to value $\tautology$ or $\nil$.  A constant node has no incoming arcs.
\item[Input:] Corresponds to one of the variables in $X$.   A variable node has no incoming arcs.
\item[Operator:] Represents an application of the $\ite$ operation.  An operator node has three incoming arcs, labeled \ifarg{}, \thenarg{}, and \elsearg{}, corresponding to the three arguments of the $\ite$ operation.
\end{description}  

When describing ITE graphs, we refer to constant and input
nodes by their associated value or variable.  An operator node is described by an expression of the form
$\ite(v_i, v_t, v_e)$, where $v_i$, $v_t$, and $v_e$ are the
nodes corresponding to the \ifarg{}, \thenarg{}, and \elsearg{} inputs, respectively.

We can define the function $\depend$ mapping each node
$v$ in an ITE graph to the set of variables on which it logically depends.  This can be expressed recursively as
\begin{eqnarray}
\depend(\tautology) & = & \emptyset \label{eqn:depend:true}\\
\depend(\nil) & = & \emptyset \label{eqn:depend:false}\\
\depend(x) & = & \{x \} \label{eqn:depend:variable}\\
\depend(\ite(x, v_t, v_e)) & = & \depend(v_i) \cup \depend(v_t) \cup \depend(v_e) \label{eqn:depend:ite}
\end{eqnarray}  


\begin{lemma}
\label{lemma:independent:dset}
Any node $v$ in an ITE graph is independent of any variable $y \in X$ such that $y \not \in \depend(v)$.
\end{lemma}  
\noindent
{\em Proof:} Follows by the recursive definition of $\depend$ (\ref{eqn:depend:true}--\ref{eqn:depend:ite}) and by (\ref{eqn:ite:interp}).

A {\em variable-partitioned} ITE (VPITE) graph is one satisfying the property
that for every operator node $v = \ite(v_i, v_t, v_e)$, the dependency
set of its \ifarg{} input most be disjoint from those of its
\thenarg{} and \elsearg{} inputs.  That is, both $\depend(v_i) \cap \depend(v_t) = \emptyset$ and
$\depend(v_i) \cap \depend(v_e) = \emptyset$.

\section{Model Counting VPITE Graphs}

While model counting is a difficult problem for arbitrary
formulas, it readily be computed when $F$ takes the form of a VPITE graph.

\begin{theorem}
\label{theorem:count}
Letting $n = |X|$, the following recursive formula holds for any node in a VPITE graph:
\begin{eqnarray}
\mcount(\tautology) & = & 2^{n} \label{eqn:count:true}\\
\mcount(\nil) & = & 0 \label{eqn:count:false}\\
\mcount(x) & = & 2^{n-1} \label{eqn:count:variable}\\
\mcount[\ite(v_i, v_t, v_e)] & = & \frac{\mcount(v_i) \cdot \mcount(v_t) + [2^n-\mcount(v_i)] \cdot \mcount(v_e)}{2^n} \label{eqn:count:ite}
\end{eqnarray}  
\end{theorem}
\noindent
{\em Proof:} The key result here is (\ref{eqn:count:ite}).  It follows
from Lemmas~\ref{lemma:negation}--\ref{lemma:sum}, along with the definition of the ITE operator.


\section{Relation to Other Representations}

In general, there is a trade-off between the compactness of different
Boolean function representations versus the ease with which different
properties can readily be computed.  For example, Boolean formulas and
Boolean circuits can be very compact, but basic properties of these
representations, such as satisfiability, equivalence testing, and
model counting are NP-hard.  On the other hand all of these properties
can be computed in polynomial time for reduced, orderd binary decision
diagrams (ROBDDs)~\cite{Bryant:1986}, but they can grow exponentially
in relation to the representation of the function as a formula or
circuit.  ITE graphs lie somewhere between these two extremes.  Here
we examine how they relate to other representations and the implications
of these relations.

\subsection{Binary Decision Diagrams}

Binary Decision Diagrams~\cite{akers:ieeetc:1978} also represent Boolean formulas
as directed graphs consisting of ITE operators.  They can be seen as
equivalent to a class of graphs we will call {\em input-controlled} ITE
graphs.  These are ones for which the \ifarg{} input to every operator
node is a variable.

If we combine the properties of variable partitioned and input
control, we arrive at the representation known as {\em
  Free}~BDDs~\cite{gergov:ieeetc:1994}.  If we further restrict the
variables in a variable-controlled, input-partitioned ITE graph to
obey the same ordering along all paths formed in the graph, we arrive
at OBDDs.  An OBDD can be reduced by a simple set of rules to give an
ROBDD representation, and this form is canonical~\cite{Bryant:1986}.

\subsection{Sententential Decision Diagrams}

Darwiche uses the Sentential Decision Diagram (SDD)
representation~\cite{darwiche:ijcai:2011} as his framework for several
model counting programs.  An SDD can be seen as a combination of 1) a
generalization of VPITE graphs consisting of $k$-input multiplexors,
and 2) an ordering restriction on the variables.
That is, each operator node in an SDD is defined to
have $k$ data inputs and $k$ control inputs, where the Boolean
functions corresponding to the control inputs $p_1, p_2, \ldots, p_k$
satisfy $p_i \land p_j = \nil$ for $1 \leq i < j \leq k$ and
$\bigvee_{i=1,k} p_i = \tautology$.  The $k$ data inputs represent
Boolean functions $s_1, s_2, \ldots, s_k$.  In addition, the
dependency sets for the control and data inputs must be disjoint:
$\depend(p_i) \cap \depend(s_j) = \emptyset$ for $1 \leq i,j \leq k$.
Furthermore, the ordering of the variables in an SDD must obey a hierarchical decomposition
defined by
a tree structure known as a {\em vtree}.  Indeed, an SDD can be seen
as equivalent to a generalization of BDDs devised by McMillan, which
he termed {\em tree} BDDs~\cite{mcmillan:cav:1994}.

The graph part of an SDD can be readily translated into a VPITE graph
by expanding each $k$-input node into $k-1$ ITE nodes, giving an
output value defined as:
\begin{displaymath}
\ite(p_1, s_1, \ite(p_2, s_2, \ite( \cdots \ite(p_{k-1}, s_{k-1}, s_k)\cdots))
\end{displaymath}
If we express the size of an SDD as the number of branches, this
translation from SDD to ITE graph will expand the size by a constant
factor.


\section{Probabilistic Equivalence Checking}

One further feature of VPITE graphs is that there is a randomized
polynomial time (RP) algorithm for determining whether two graphs
represent equivalent Boolean functions.  This algorithm generalizes
the RP equivalence-testing algorithm for free BDDs described by Blum,
Chandra, and Wegman~\cite{blum:ipl:1980}.

\bibliography{references}

\end{document}


\section{A Model Counting Calculus}

Objective: Create a simple system for defining and reasoning about an
abstraction of Boolean formulas that suffices for tracking the number
of models.  


Define a {\em counting subspace} $\subspace{} = \langle V, \alpha, k\rangle$, with:
\begin{itemize}
\item $V$ is a set of variables
\item $\alpha$ is a partial assignment to variables in $V$, represented as a set of literals.
\item $k$ is an integer, indicating the number of models for
  the formula within the specified subspace.  For $n = |V|$ and $m= |\var(\alpha)|$, it satisfies
  $0 \leq k \leq 2^{n-m}$.
\end{itemize}

\subsection{Subspace Primitives}
\begin{itemize}
\item
Universal subspace: $\langle \emptyset, \emptyset, 1 \rangle$.
\item
Null subspace: $\langle \emptyset, \emptyset, 0 \rangle$.
\item
  Positive literal: $\langle \{ x\}, \{x\}, 1\rangle$.
\item
  Negative literal: $\langle \{ x\}, \{\obar{x}\}, 1\rangle$.
\item
  Unused variable: $\langle \{ x\}, \emptyset, 2\rangle$.
\end{itemize}

\subsection{Basic Subspace Operations}

Assume $\subspace_1 = \langle V_1, \alpha_1, k_1\rangle$ and
$\subspace_2 = \langle V_2, \alpha_2, k_2\rangle$ are two subspaces

Subspace product $\subspace_1 \times \subspace_2$
\begin{itemize}
\item Condition: $V_1 \cap V_2 = \emptyset$
\item Result: $\langle V_1 \cup V_2, \alpha_1 \cup \alpha_2, k_1 \cdot k_2\rangle$.
\end{itemize}

Subspace Sum $\subspace_1 + \subspace_2$
\begin{itemize}
\item Conditions:
  \begin{itemize}
  \item $V_1 = V_2$.
  \item For some literal $l$ of variable $x \in V_1$ and assignment $\alpha$, the argument assignments satisfy
    $\alpha_1 = \alpha \cup \{l\}$ and $\alpha_2 = \alpha \cup \{ \obar{l} \}$.
  \end{itemize}
\item Result: $\langle V_1 - \{ x\}, \alpha, (k_1 + k_2)/2\rangle$.
\end{itemize}
  
\subsection{Derived Subspace Operations}

These useful operations can be constructed by combining primitive values and basic operations.

Expanding subspace $\subspace{} = \langle V, \alpha, k\rangle$:
\begin{itemize}
\item
  Condition: $x \not \in V$
\item
  Results:
  \begin{itemize}
    \item Positive expansion: $\langle V \cup \{ x \}, \alpha \cup \{ x \}, k \rangle$.
    \item Negative expansion: $\langle V \cup \{ x \}, \alpha \cup \{ \obar{x} \}, k \rangle$.
    \item Don't-care expansion: $\langle V \cup \{ x \}, \alpha , 2\cdot k \rangle$.
  \end{itemize}
\end{itemize}

A particularly useful expansion is to apply the don't-care expansion
with a set of variables $U$ such that $U \cap V = \emptyset$.  This
will give the subspace $\langle U \cup V, \alpha, 2^{|U|} \cdot
k\rangle$.


