\section{A Formally Verified CRAT Checker and POG Model Counter}

We have implemented the rightmost two components of Figure~\ref{fig:chain}, namely the
proof checker and both model and weighted model counters, in the \lean{} programming language
and proof assistant~\cite{demoura:cade:2021}.
In this section, we briefly describe the functions we have implemented in Lean and
the specifications we have proved.
More information is provided in the Appendix~\ref{appendix:lean}.

\subsection{The Proof Checker}
\label{subsection:proof:checker}

Our specifications are built on a generic library for the syntax and semantics of
propositional logic. We define the data type \lstinline{PropForm Var} of propositional
formulas with variables \lstinline{Var}, which are positive natural numbers,
corresponding to the indexing of variables in the CNF and CRAT files.
It is convenient to take a truth assignment \lstinline{PropAssignment Var} to a function that
assigns a Boolean value to every assignment, and later restrict attention to subsets of the
variables.

We define the following representations for CNF formulas.
A literal is represented as a nonzero integer, a clause is an array of literals,
and a CNF formula is an array of clauses.
\begin{lstlisting}
def ILit := { i : Int // i ≠ 0 }
abbrev IClause := Array ILit
abbrev ICnf := Array IClause
\end{lstlisting}
We also define functions \lstinline{ILit.toPropForm}, \lstinline{IClause.toPropForm},
and \lstinline{ICnf.toPropForm} to relate these to propositional formulas and their
semantics.

The goal of the proof checker is to construct a POG that is equivalent to the input CNF.
Each element of a POG  is either a variable, a binary disjunction (sum),
or an arbitrary conjunction (product):
\begin{lstlisting}
inductive PogElt where
  | var  : Var → PogElt
  | disj : Var → ILit → ILit → PogElt
  | conj : Var → Array ILit → PogElt
\end{lstlisting}
In the first case, the argument \lstinline{x} in the expression
\lstinline{var x} is the index
of the variable; in \lstinline{disj x left right} and \lstinline{conj x args}
it is the definition number in the CRAT file. Note that representing edges as literals allows us to negate the arguments to \lstinline{disj} and \lstinline{conj}.
A \lstinline{Pog} is then simply an array of \lstinline{PogElt}.
For each POG \lstinline{P} and literal \lstinline{l}, we define
\lstinline{P.toPropForm l} to be the
propositional formula that arises from interpreting \lstinline{l} as a propositional
formula, unfolding all the defined conjunctions and disjunctions.
A partitioned-operation formula, as defined in \cref{section:logical:foundations}, is expressed as:
\begin{lstlisting}
def partitioned : PropForm Var → Prop
 | tr | fls | var _ => True
 | neg φ    => φ.partitioned
 | disj φ ψ => φ.partitioned ∧ ψ.partitioned ∧ ∀ τ, ¬(φ.eval τ ∧ ψ.eval τ)
 | conj φ ψ => φ.partitioned ∧ ψ.partitioned ∧ (φ.vars ∩ ψ.vars = ∅)
\end{lstlisting}

Our proof checker starts by parsing the CNF formula and storing it internally.
It then processes and checks each rule of a CRAT proof, throwing an exception if
the proof is not well-formed. We have proved that if the checker terminates successfully,
it succeeds in constructing a POG that is partitioned and equivalent to that CNF. This is formalized as \lstinline{(pog.toPropForm r).partitioned ∧ inputCnf.toPropForm ≡ pog.toPropForm r}.

\subsection{The Model Counters}
\label{subsection:counting}

We have formalized the central quantity (\ref{eqn:rep}) in the ring evaluation problem,
\cref{def:ring_evaluation}, as follows:
\begin{lstlisting}
def weightCount {R : Type} [CommRing R]
    (weight : Var → R) (φ : PropForm Var) (s : Finset Var) : R :=
  ∑ τ in models φ s, ∏ x in s, if τ x then weight x else 1 - weight x
\end{lstlisting}
Here \lstinline{R} is assumed to be a commutative ring.
The counting scheme of Proposition~\ref{prop:ring:eval} for partitioned formulas is expressed as follows:
\begin{lstlisting}
 def ringEval (weight : Var → R) : PropForm Var → R
  | tr       => 1
  | fls      => 0
  | var x    => weight x
  | neg φ    => 1 - ringEval weight φ
  | disj φ ψ => ringEval weight φ + ringEval weight ψ
  | conj φ ψ => ringEval weight φ * ringEval weight ψ
\end{lstlisting}
Proposition~\ref{prop:ring:eval} is then formalized as follows:
\begin{lstlisting}
theorem ringEval_eq_weightCount (weight : Var → R) {φ : PropForm Var} :
    partitioned φ → ringEval weight φ = weightCount weight φ (vars φ)
\end{lstlisting}

We have implemented an efficient function \lstinline{Pog.ringEval} to calculate the weighted model count
for an arbitrary node of a Pog, and we have proved that it computes the function above on the
associated formula:
\begin{lstlisting}
theorem ringEval_eq_ringEval (pog : Pog) (weight : Var → R) (x : Var) :
  pog.ringEval weight x = (pog.toPropForm (.mkPos x)).ringEval weight
\end{lstlisting}
Here \lstinline{.mkPos x} denotes the positive literal for the variable \lstinline{x}.
Applying this to the output of our verified CRAT proof checker,
we obtain a proof that
our toolchain computes the correct weighted model count of the input CNF.

We have also implemented a separate procedure that directly carries out an integer
calculation of the number of models.
For partitioned formulas \lstinline{PropForm Var} whose
variables are among a finite set \lstinline{s} of variables of cardinality \lstinline{numVars},
we can count the number of models of the formula on the variables in \lstinline{s}
recursively as follows:
\begin{lstlisting}
def countModels (nVars : Nat) : PropForm Var → Nat
  | tr       => 2^nVars
  | fls      => 0
  | var _    => 2^(nVars - 1)
  | neg φ    => 2^nVars - countModels nVars φ
  | disj φ ψ => countModels nVars φ + countModels nVars ψ
  | conj φ ψ => countModels nVars φ * countModels nVars ψ / 2^nVars
\end{lstlisting}
We have implemented an efficient counting function for POGs and proved that
it computes that same quantity on the corresponding formulas.
Finally,
we have proved that the calculation above really does
return the number of models:
\begin{lstlisting}
theorem countModels_eq_card_models {φ : PropForm Var} {s : Finset Var} :
  vars φ ⊆ s → partitioned φ → countModels (card s) φ = card (models φ s)
\end{lstlisting}
In particular, taking \lstinline{s} to be exactly the variables of \lstinline{φ},
we have that the number of models on its variables is \lstinline{countModels φ (card (vars φ))}.
